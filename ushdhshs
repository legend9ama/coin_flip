#include <avr/io.h>
#include <avr/interrupt.h>

// Pin configuration
#define LASER_PIN PD6     // PD6 (Digital 6) - Laser output
#define SIGNAL_PIN PD2    // PD2 (Digital 2) - Digital signal input (INT0)

// FSK Frequencies for 8MHz clock
#define FSK_LOW_FREQ 100     // Hz (bit 0)
#define FSK_HIGH_FREQ 400    // Hz (bit 1)
#define FSK_SYNC_FREQ 50     // Hz (synchronization)
#define BAUD_RATE 600        // bits per second

// FSK Protocol
#define SYNC_BYTE 0xAA
#define START_BYTE 0x7E
#define STOP_BYTE 0x7F

// Global variables
volatile uint32_t pulse_times[8] = {0};
volatile uint8_t pulse_index = 0;
volatile uint32_t current_time = 0;
volatile uint8_t synchronized = 0;
volatile uint16_t measured_frequency = 0;
volatile uint8_t debug_enabled = 1;

// FSK Reception variables
volatile uint8_t receiving_data = 0;
volatile uint8_t receiving_byte = 0;
volatile uint8_t bit_position = 0;
volatile uint8_t received_bytes[32];
volatile uint8_t rx_index = 0;
volatile uint16_t recent_periods[8] = {0};
volatile uint8_t period_index = 0;

// FSK Transmission variables
volatile uint8_t transmission_active = 0;
volatile uint8_t transmit_buffer[32];
volatile uint8_t tx_index = 0;
volatile uint8_t tx_length = 0;
volatile uint8_t current_bit = 0;
volatile uint32_t bit_start_time = 0;
volatile uint8_t current_fsk_state = 0;

// Function declarations
void process_fsk_reception(uint32_t now);
void process_bit_transmission(void);

// UART functions for 8MHz
void uart_init(void) {
    UBRR0H = 0;
    UBRR0L = 51;
    UCSR0B = (1 << TXEN0) | (1 << RXEN0);
    UCSR0C = (1 << UCSZ01) | (1 << UCSZ00);
}

void uart_putchar(char c) {
    while (!(UCSR0A & (1 << UDRE0)));
    UDR0 = c;
}

void uart_print(const char* str) {
    while (*str) {
        uart_putchar(*str++);
    }
}

void uart_println(const char* str) {
    uart_print(str);
    uart_putchar('\r');
    uart_putchar('\n');
}

void uart_print_hex(uint8_t num) {
    char hex_chars[] = "0123456789ABCDEF";
    uart_putchar(hex_chars[(num >> 4) & 0x0F]);
    uart_putchar(hex_chars[num & 0x0F]);
}

void uart_print_number(uint16_t num) {
    if (num >= 10000) uart_putchar('0' + (num / 10000) % 10);
    if (num >= 1000) uart_putchar('0' + (num / 1000) % 10);
    if (num >= 100) uart_putchar('0' + (num / 100) % 10);
    if (num >= 10) uart_putchar('0' + (num / 10) % 10);
    uart_putchar('0' + num % 10);
}

// Timer0 initialization
void timer0_init(void) {
    TCCR0A = (1 << WGM01);
    TCCR0B = (1 << CS01) | (1 << CS00);
    OCR0A = 124;
    TIMSK0 = (1 << OCIE0A);
}

// Timer1 initialization
void timer1_init(void) {
    TCCR1A = (1 << COM1A1) | (1 << WGM11);
    TCCR1B = (1 << WGM13) | (1 << WGM12) | (1 << CS11);
}

// External interrupt initialization
void ext_interrupt_init(void) {
    EICRA = (1 << ISC01);
    EIMSK = (1 << INT0);
}

// GPIO initialization
void gpio_init(void) {
    DDRD |= (1 << LASER_PIN);
    DDRD &= ~(1 << SIGNAL_PIN);
    PORTD |= (1 << SIGNAL_PIN);
}

// Set FSK frequency
void set_fsk_frequency(uint8_t fsk_type) {
    uint16_t top_value;
    
    switch(fsk_type) {
        case 0:
            top_value = (8000000UL / (8 * FSK_LOW_FREQ)) - 1;
            break;
        case 1:
            top_value = (8000000UL / (8 * FSK_HIGH_FREQ)) - 1;
            break;
        case 2:
            top_value = (8000000UL / (8 * FSK_SYNC_FREQ)) - 1;
            break;
        default:
            return;
    }
    
    ICR1 = top_value;
    OCR1A = top_value / 2;
    
    if (current_fsk_state != fsk_type && debug_enabled) {
        uart_print("FSK: ");
        switch(fsk_type) {
            case 0: uart_println("100Hz(0)"); break;
            case 1: uart_println("400Hz(1)"); break;
            case 2: uart_println("50Hz(SYNC)"); break;
        }
    }
    current_fsk_state = fsk_type;
}

// Set laser constant ON
void set_laser_constant(void) {
    TCCR1A &= ~(1 << COM1A1);
    PORTD |= (1 << LASER_PIN);
    synchronized = 0;
    
    if (debug_enabled && current_fsk_state != 3) {
        uart_println("LASER: CONSTANT ON");
    }
    current_fsk_state = 3;
}

// Measure input signal frequency
uint16_t measure_input_frequency(void) {
    if (pulse_index < 2) return 0;
    
    uint32_t total_period = 0;
    uint8_t valid_measurements = 0;
    
    for (uint8_t i = 0; i < 8; i++) {
        if (recent_periods[i] > 0) {
            total_period += recent_periods[i];
            valid_measurements++;
        }
    }
    
    if (valid_measurements == 0 || total_period == 0) return 0;
    
    uint32_t avg_period = total_period / valid_measurements;
    if (avg_period == 0) return 0;
    
    return 1000 / avg_period;
}

// Detect FSK bit
uint8_t detect_fsk_bit(uint16_t frequency) {
    if (frequency == 0) return 3;
    
    if (frequency > FSK_HIGH_FREQ - 80 && frequency < FSK_HIGH_FREQ + 80) {
        return 1;
    } else if (frequency > FSK_LOW_FREQ - 30 && frequency < FSK_LOW_FREQ + 30) {
        return 0;
    } else if (frequency > FSK_SYNC_FREQ - 15 && frequency < FSK_SYNC_FREQ + 15) {
        return 2;
    }
    return 3;
}

// Start FSK transmission
void start_fsk_transmission(uint8_t* data, uint8_t length) {
    if (transmission_active || length > 32) return;
    
    for (uint8_t i = 0; i < length; i++) {
        transmit_buffer[i] = data[i];
    }
    tx_length = length;
    tx_index = 0;
    transmission_active = 1;
    current_bit = 0;
    
    if (debug_enabled) {
        uart_print("TX: ");
        uart_print_number(length);
        uart_println(" bytes");
    }
    
    set_fsk_frequency(2);
    bit_start_time = current_time;
}

// Process FSK transmission
void process_fsk_transmission(void) {
    if (!transmission_active) return;
    
    uint32_t current_time_safe = current_time;
    uint32_t bit_duration = 1000 / BAUD_RATE;
    
    if (current_time_safe >= bit_start_time) {
        if (current_time_safe - bit_start_time >= bit_duration) {
            bit_start_time = current_time_safe;
            process_bit_transmission();
        }
    } else {
        bit_start_time = current_time_safe;
    }
}

// Process one bit of transmission
void process_bit_transmission(void) {
    if (tx_index == 0) {
        if (current_bit < 16) {
            set_fsk_frequency(2);
            current_bit++;
        } else {
            tx_index++;
            current_bit = 0;
            set_fsk_frequency(0);
        }
    } else if (tx_index <= tx_length) {
        if (current_bit == 0) {
            set_fsk_frequency(0);
            current_bit++;
        } else if (current_bit <= 8) {
            uint8_t bit_value = (transmit_buffer[tx_index-1] >> (current_bit - 1)) & 1;
            set_fsk_frequency(bit_value);
            current_bit++;
        } else {
            set_fsk_frequency(1);
            tx_index++;
            current_bit = 0;
            
            if (tx_index > tx_length) {
                transmission_active = 0;
                if (debug_enabled) uart_println("TX DONE");
                if (synchronized) set_fsk_frequency(2);
            }
        }
    }
}

// Process received FSK data
void process_received_data(void) {
    if (rx_index >= 3) {
        if (received_bytes[0] == START_BYTE && received_bytes[rx_index-1] == STOP_BYTE) {
            if (debug_enabled) {
                uart_print("RX: '");
                for (uint8_t i = 1; i < rx_index-1; i++) {
                    uart_putchar(received_bytes[i]);
                }
                uart_println("'");
            }
            
            uint8_t response[] = {START_BYTE, 'O', 'K', STOP_BYTE};
            start_fsk_transmission(response, 4);
        }
    }
    rx_index = 0;
}

// Process FSK reception
void process_fsk_reception(uint32_t now) {
    uint8_t detected_bit = detect_fsk_bit(measured_frequency);
    static uint32_t last_bit_time = 0;
    static uint8_t stable_count = 0;
    
    if (detected_bit < 2) {
        if (!receiving_data) {
            if (detected_bit == 0) {
                stable_count++;
                if (stable_count >= 2) {
                    receiving_data = 1;
                    receiving_byte = 0;
                    bit_position = 0;
                    last_bit_time = now;
                    stable_count = 0;
                }
            } else {
                stable_count = 0;
            }
        } else {
            stable_count++;
            if (stable_count >= 2) {
                uint32_t bit_time;
                
                if (now >= last_bit_time) {
                    bit_time = now - last_bit_time;
                } else {
                    bit_time = (0xFFFFFFFF - last_bit_time) + now + 1;
                }
                
                uint32_t expected_bit_time = 1000 / BAUD_RATE;
                
                if (bit_time >= expected_bit_time * 0.7) {
                    if (bit_position < 8) {
                        receiving_byte |= (detected_bit << bit_position);
                        bit_position++;
                    } else {
                        if (detected_bit == 1 && rx_index < 32) {
                            received_bytes[rx_index++] = receiving_byte;
                        }
                        receiving_data = 0;
                    }
                    last_bit_time = now;
                }
                stable_count = 0;
            }
        }
    }
    else if (detected_bit == 2 && !synchronized) {
        synchronized = 1;
        if (debug_enabled) uart_println("SYNC: OK");
        if (!transmission_active) set_fsk_frequency(2);
    }
}

// Debug information
void print_debug_info(void) {
    uart_print("F:");
    uart_print_number(measured_frequency);
    uart_print("Hz S:");
    uart_print_number(synchronized);
    uart_print(" R:");
    uart_print_number(receiving_data);
    uart_println("");
}

// Timer0 Compare Match A
ISR(TIMER0_COMPA_vect) {
    current_time++;
}

// External interrupt
ISR(INT0_vect) {
    uint32_t now = current_time;
    
    if (pulse_index > 0) {
        uint32_t last_time = pulse_times[pulse_index - 1];
        uint32_t period;
        
        if (now >= last_time) {
            period = now - last_time;
        } else {
            period = (0xFFFFFFFF - last_time) + now + 1;
        }
        
        if (period >= 2 && period <= 33) {
            recent_periods[period_index] = (uint16_t)period;
            period_index = (period_index + 1) % 8;
            
            measured_frequency = 1000 / period;
            
            if (synchronized && !transmission_active) {
                process_fsk_reception(now);
            }
        }
    }
    
    pulse_times[pulse_index] = now;
    pulse_index = (pulse_index + 1) % 8;
}

int main(void) {
    gpio_init();
    uart_init();
    timer0_init();
    timer1_init();
    ext_interrupt_init();
    
    uart_println("=== ATmega328P 2-FSK @ 8MHz ===");
    
    set_laser_constant();
    sei();
    
    uint32_t last_mode_check = 0;
    uint32_t last_debug_out = 0;
    uint32_t last_auto_tx = 0;
    
    uart_println("READY");
    
    while (1) {
        uint32_t current_time_safe = current_time;
        
        if (current_time_safe - last_mode_check > 300) {
            uint16_t freq = measure_input_frequency();
            
            if (freq == 0 && synchronized) {
                set_laser_constant();
                synchronized = 0;
                uart_println("SYNC: LOST");
            } 
            else if (detect_fsk_bit(freq) == 2 && !synchronized) {
                synchronized = 1;
                set_fsk_frequency(2);
                uart_println("SYNC: OK");
            }
            
            last_mode_check = current_time_safe;
        }
        
        if (transmission_active) {
            process_fsk_transmission();
        }
        
        if (rx_index > 0) {
            process_received_data();
        }
        
        if (debug_enabled && (current_time_safe - last_debug_out > 2000)) {
            print_debug_info();
            last_debug_out = current_time_safe;
        }
        
        if (synchronized && !transmission_active && (current_time_safe - last_auto_tx > 10000)) {
            uint8_t data[] = {START_BYTE, 'T', 'E', 'S', 'T', STOP_BYTE};
            start_fsk_transmission(data, 6);
            last_auto_tx = current_time_safe;
        }
    }
    
    return 0;
}
